#include "foc_utils.h"

/***************************************************************************/
// 使用整型数组代替浮点型数组
// 每360度有4x200个点
// 节省2倍存储空间（整型2字节，浮点型4字节）
// sine_array中的值为sin(angle) * 10000的整数近似值
const int sine_array[200] = {
    0, 79, 158, 237, 316, 395, 473, 552, 631, 710, 789, 867, 946, 1024, 1103, 1181,
    1260, 1338, 1416, 1494, 1572, 1650, 1728, 1806, 1883, 1961, 2038, 2115,
    2192, 2269, 2346, 2423, 2499, 2575, 2652, 2728, 2804, 2879, 2955, 3030,
    3105, 3180, 3255, 3329, 3404, 3478, 3552, 3625, 3699, 3772, 3845, 3918,
    3990, 4063, 4135, 4206, 4278, 4349, 4420, 4491, 4561, 4631, 4701, 4770,
    4840, 4909, 4977, 5046, 5113, 5181, 5249, 5316, 5382, 5449, 5515, 5580,
    5646, 5711, 5775, 5839, 5903, 5967, 6030, 6093, 6155, 6217, 6279, 6340,
    6401, 6461, 6521, 6581, 6640, 6699, 6758, 6815, 6873, 6930, 6987, 7043,
    7099, 7154, 7209, 7264, 7318, 7371, 7424, 7477, 7529, 7581, 7632, 7683,
    7733, 7783, 7832, 7881, 7930, 7977, 8025, 8072, 8118, 8164, 8209, 8254,
    8298, 8342, 8385, 8428, 8470, 8512, 8553, 8594, 8634, 8673, 8712, 8751,
    8789, 8826, 8863, 8899, 8935, 8970, 9005, 9039, 9072, 9105, 9138, 9169,
    9201, 9231, 9261, 9291, 9320, 9348, 9376, 9403, 9429, 9455, 9481, 9506,
    9530, 9554, 9577, 9599, 9621, 9642, 9663, 9683, 9702, 9721, 9739, 9757,
    9774, 9790, 9806, 9821, 9836, 9850, 9863, 9876, 9888, 9899, 9910, 9920,
    9930, 9939, 9947, 9955, 9962, 9969, 9975, 9980, 9985, 9989, 9992, 9995,
    9997, 9999, 10000, 10000
};

/***************************************************************************/
// 通过固定大小的数组近似计算正弦函数
// 使用整型数组时大约需50微秒，使用浮点型数组时大约需40微秒
// 精度误差约为±0.005
// 输入角度必须在0到2π之间
float _sin(float a){
    if(a < _PI_2){
        // 第1象限：0到π/2
        // 通过计算索引值，从sine_array中获取近似值，并缩放回原始范围
        // return sine_array[(int)(199.0*( a / (_PI/2.0)))];
        // return sine_array[(int)(126.6873* a)];           // 使用浮点型数组优化版
        return 0.0001 * sine_array[_round(126.6873 * a)]; // 使用整型数组优化版
    }
    else if(a < _PI){
        // 第2象限：π/2到π
        // 通过对索引值进行反向计算，从sine_array中获取近似值，并缩放回原始范围
        // return sine_array[(int)(199.0*(1.0 - (a-_PI/2.0) / (_PI/2.0)))];
        // return sine_array[398 - (int)(126.6873*a)];          // 使用浮点型数组优化版
        return 0.0001 * sine_array[398 - _round(126.6873 * a)]; // 使用整型数组优化版
    }
    else if(a < _3PI_2){
        // 第3象限：π到3π/2
        // 通过计算索引值获取负的正弦值
        // return -sine_array[(int)(199.0*((a - _PI) / (_PI/2.0)))];
        // return -sine_array[-398 + (int)(126.6873*a)];           // 使用浮点型数组优化版
        return -0.0001 * sine_array[-398 + _round(126.6873 * a)]; // 使用整型数组优化版
    }
    else {
        // 第4象限：3π/2到2π
        // 通过计算索引值获取负的正弦值
        // return -sine_array[(int)(199.0*(1.0 - (a - 3*_PI/2) / (_PI/2.0)))];
        // return -sine_array[796 - (int)(126.6873*a)];           // 使用浮点型数组优化版
        return -0.0001 * sine_array[796 - _round(126.6873 * a)]; // 使用整型数组优化版
    }
}

/***************************************************************************/
// 通过固定大小的数组近似计算余弦函数
// 使用浮点型数组时大约需55微秒，使用整型数组时大约需56微秒
// 精度误差约为±0.005
// 输入角度必须在0到2π之间
float _cos(float a){
    float a_sin = a + _PI_2; // 余弦函数相位提前π/2，转换为正弦函数
    a_sin = a_sin > _2PI ? a_sin - _2PI : a_sin; // 归一化角度到0到2π
    return _sin(a_sin); // 调用正弦函数进行计算
}

/***************************************************************************/
// 将弧度角度归一化到[0, 2π]范围内
float _normalizeAngle(float angle){
    float a = fmod(angle, _2PI); // 取角度的模2π
    return a >= 0 ? a : (a + _2PI); // 如果结果为负数，则加2π使其为正数
}

/***************************************************************************/
// 计算电气角度
// shaft_angle为机械角度，pole_pairs为极对数
float _electricalAngle(float shaft_angle, int pole_pairs) {
    return (shaft_angle * pole_pairs); // 电气角度 = 机械角度 * 极对数
}

/***************************************************************************/
// 使用快速逆平方根算法近似计算平方根
// 参考：https://reprap.org/forum/read.php?147,219210
// 参考：https://en.wikipedia.org/wiki/Fast_inverse_square_root
float _sqrtApprox(float number) { // 简单实现
    long i;
    float y;
    // float x;
    // const float f = 1.5F; // 更高精度（已注释）

    // x = number * 0.5F; // 已注释

    y = number; // 将输入数赋值给y
    i = *(long *)&y; // 将浮点数y的比特位重新解释为长整型i
    i = 0x5f375a86 - (i >> 1); // 使用魔法数和位移操作进行初步近似
    y = *(float *)&i; // 将整型i的比特位重新解释为浮点数y
    // y = y * (f - (x * y * y)); // 使用牛顿迭代法提高精度（已注释）
    return number * y; // 返回近似的平方根值
}

/***************************************************************************/